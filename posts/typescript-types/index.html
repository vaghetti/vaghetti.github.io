<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A better mental model for reasoning about Typescript types | Douglas Vaghetti</title>
<meta name=keywords content><meta name=description content="I work in a pretty big Typescript code base on my day job. The one thing I see people struggling the most when learning it is the type system.
Typescript types are rather special in that they exist during compile time but not during runtime. I believe it is a better mental model to think of them as type annotations than proper types like the ones you get in a language like Go or Java."><meta name=author content="Douglas Vaghetti"><link rel=canonical href=https://vaghetti.dev/posts/typescript-types/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/apple-touch-icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://vaghetti.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://vaghetti.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://vaghetti.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://vaghetti.dev/apple-touch-icon.png><link rel=mask-icon href=https://vaghetti.dev/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vaghetti.dev/posts/typescript-types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/applause-button.css><script src=/applause-button.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-0WM35LFYW7"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0WM35LFYW7")}</script><meta property="og:title" content="A better mental model for reasoning about Typescript types"><meta property="og:description" content="I work in a pretty big Typescript code base on my day job. The one thing I see people struggling the most when learning it is the type system.
Typescript types are rather special in that they exist during compile time but not during runtime. I believe it is a better mental model to think of them as type annotations than proper types like the ones you get in a language like Go or Java."><meta property="og:type" content="article"><meta property="og:url" content="https://vaghetti.dev/posts/typescript-types/"><meta property="og:image" content="https://vaghetti.dev/apple-touch-icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-16T11:16:29-03:00"><meta property="article:modified_time" content="2022-07-16T11:16:29-03:00"><meta property="og:site_name" content="Douglas Vaghetti"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vaghetti.dev/apple-touch-icon.png"><meta name=twitter:title content="A better mental model for reasoning about Typescript types"><meta name=twitter:description content="I work in a pretty big Typescript code base on my day job. The one thing I see people struggling the most when learning it is the type system.
Typescript types are rather special in that they exist during compile time but not during runtime. I believe it is a better mental model to think of them as type annotations than proper types like the ones you get in a language like Go or Java."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vaghetti.dev/posts/"},{"@type":"ListItem","position":2,"name":"A better mental model for reasoning about Typescript types","item":"https://vaghetti.dev/posts/typescript-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A better mental model for reasoning about Typescript types","name":"A better mental model for reasoning about Typescript types","description":"I work in a pretty big Typescript code base on my day job. The one thing I see people struggling the most when learning it is the type system.\nTypescript types are rather special in that they exist during compile time but not during runtime. I believe it is a better mental model to think of them as type annotations than proper types like the ones you get in a language like Go or Java.","keywords":[],"articleBody":"I work in a pretty big Typescript code base on my day job. The one thing I see people struggling the most when learning it is the type system.\nTypescript types are rather special in that they exist during compile time but not during runtime. I believe it is a better mental model to think of them as type annotations than proper types like the ones you get in a language like Go or Java.\nLet me give an example in Go:\ntype MyType struct { A int B int } func myFunction(input MyType) { bytes, _ := json.Marshal(str) fmt.Println(string(bytes)) } In the example above, the Go type system guarantees whatever is passed into your function will have the A and B fields, they’ll both be integers and no other field is going to be there. Anything else simply won’t compile.\nFor comparison, take a look at this similar piece Typescript code:\ntype MyType = { a: number; b: number; } function myFunction(input: MyType){ console.log(JSON.stringify(input)) } If you’re coming into Typescript from a strongly typed language background like me, you might assume these two pieces of code would offer similar guarantees to the myFunction function. That’s not always the case in Typescript. Let’s see some interesting things Typescript will allow you to do with this function:\nmyFunction({ a: 1, b: 2 }); // works fine as expected, outputs {\"a\":1,\"b\":2} myFunction({ a: 1, b: 2, c: 3 }); // Won't compile myFunction({ a: 1, b: 2, c: 3 } as MyType); // works fine, outputs {\"a\":1,\"b\":2,\"c\":3} myFunction('im just a string!' as MyType); // Won't compile, thankfully myFunction(('im just a string!' as unknown) as MyType); // Works fine, outputs \"im just a string!\", but at this point it is quite obvious we're doing something wrong It really boils down to the behavior of the as keyword – as is not a cast. You can’t cast anything in Typescript because there are no Typescript types in runtime! All as is doing is telling the Typescript compiler something like “relax, compiler, I know what I’m doing.”.\nHere’s what the compiled Javascript code for the functions above looks like:\nmyFunction({ a: 1, b: 2 }); // works fine as expected, outputs {\"a\":1,\"b\":2} myFunction({ a: 1, b: 2, c: 3 }); // Won't compile myFunction({ a: 1, b: 2, c: 3 }); // works fine, outputs {\"a\":1,\"b\":2,\"c\":3} myFunction('im just a string!'); // Won't compile, thankfully myFunction('im just a string!'); // Works fine, outputs \"im just a string!\", but at this point it is quite obvious you're doing something wrong All type annotations are simply removed in runtime. Typescript is only there until your program is compiled. After compilation, it is just plain old Javascript again.\nBecause of this, in Typescript, your type checks are as good as you make them be. They’re not a hard limitation imposed by the compiler like they are in Go. Typescript types more like hints to the rest of the code. At any point you can override them or simply use any. They’re there to help you write code that works, but they don’t change the program that will be actually executed.\nThis is something that took me some time to wrap my head around – It is a better mental model to think of Typescript as a very advanced linter for Javascript with type syntax than to think of it as a proper typed language that gets compiled into Javascript – Most Typescript typing code you write does not get compiled into Javascript, it is just used for compilation checks and then removed. If you want to have real type checks in runtime using Typescript, you have to use type guards\n","wordCount":"611","inLanguage":"en","datePublished":"2022-07-16T11:16:29-03:00","dateModified":"2022-07-16T11:16:29-03:00","author":{"@type":"Person","name":"Douglas Vaghetti"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vaghetti.dev/posts/typescript-types/"},"publisher":{"@type":"Organization","name":"Douglas Vaghetti","logo":{"@type":"ImageObject","url":"https://vaghetti.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vaghetti.dev/ accesskey=h title="Home (Alt + H)"><img src=https://vaghetti.dev/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>A better mental model for reasoning about Typescript types</h1><div class=post-meta>&lt;span title='2022-07-16 11:16:29 -0300 -0300'>July 16, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;Douglas Vaghetti</div></header><div class=post-content><p>I work in a pretty big Typescript code base on my day job.
The one thing I see people struggling the most when learning it is the type system.</p><p>Typescript types are rather special in that <em>they exist during compile time but not during runtime</em>.
I believe it is a better mental model to think of them as type annotations than proper types like the ones you get in a language like Go or Java.</p><p>Let me give an example in Go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyType</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>A</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>B</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>input</span> <span style=color:#a6e22e>MyType</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bytes</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>str</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>bytes</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the example above, the Go type system guarantees whatever is passed into your function will have the <code>A</code> and <code>B</code> fields, they&rsquo;ll both be integers and no other field is going to be there. Anything else simply won&rsquo;t compile.</p><p>For comparison, take a look at this similar piece Typescript code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyType</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>myFunction</span>(<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>MyType</span>){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>input</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you&rsquo;re coming into Typescript from a strongly typed language background like me, you might assume these two pieces of code would offer similar guarantees to the <code>myFunction</code> function.
That&rsquo;s not always the case in Typescript.
Let&rsquo;s see some interesting things Typescript will allow you to do with this function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>myFunction</span>({ <span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>1</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>2</span> }); <span style=color:#75715e>// works fine as expected, outputs {&#34;a&#34;:1,&#34;b&#34;:2}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>({ <span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>1</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>2</span>, <span style=color:#a6e22e>c</span>: <span style=color:#66d9ef>3</span> }); <span style=color:#75715e>//  Won&#39;t compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>({ <span style=color:#a6e22e>a</span>: <span style=color:#66d9ef>1</span>, <span style=color:#a6e22e>b</span>: <span style=color:#66d9ef>2</span>, <span style=color:#a6e22e>c</span>: <span style=color:#66d9ef>3</span> } <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>MyType</span>); <span style=color:#75715e>// works fine, outputs {&#34;a&#34;:1,&#34;b&#34;:2,&#34;c&#34;:3}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>(<span style=color:#e6db74>&#39;im just a string!&#39;</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>MyType</span>); <span style=color:#75715e>// Won&#39;t compile, thankfully
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>((<span style=color:#e6db74>&#39;im just a string!&#39;</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>unknown</span>) <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>MyType</span>); <span style=color:#75715e>// Works fine, outputs &#34;im just a string!&#34;, but at this point it is quite obvious we&#39;re doing something wrong
</span></span></span></code></pre></div><p>It really boils down to the behavior of the <code>as</code> keyword &ndash; <code>as</code> is <em>not</em> a cast.
You can&rsquo;t cast anything in Typescript because there are no Typescript types in runtime!
All <code>as</code> is doing is telling the Typescript compiler something like <em>&ldquo;relax, compiler, I know what I&rsquo;m doing.&rdquo;</em>.</p><p>Here&rsquo;s what the compiled Javascript code for the functions above looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>myFunction</span>({ <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span> }); <span style=color:#75715e>// works fine as expected, outputs {&#34;a&#34;:1,&#34;b&#34;:2}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>({ <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span> }); <span style=color:#75715e>//  Won&#39;t compile
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>({ <span style=color:#a6e22e>a</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>c</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span> }); <span style=color:#75715e>// works fine, outputs {&#34;a&#34;:1,&#34;b&#34;:2,&#34;c&#34;:3}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>(<span style=color:#e6db74>&#39;im just a string!&#39;</span>); <span style=color:#75715e>// Won&#39;t compile, thankfully
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myFunction</span>(<span style=color:#e6db74>&#39;im just a string!&#39;</span>); <span style=color:#75715e>// Works fine, outputs &#34;im just a string!&#34;, but at this point it is quite obvious you&#39;re doing something wrong
</span></span></span></code></pre></div><p>All type annotations are simply removed in runtime.
Typescript is only there until your program is compiled.
After compilation, it is just plain old Javascript again.</p><p>Because of this, in Typescript, your type checks are as good as you make them be.
They&rsquo;re not a hard limitation imposed by the compiler like they are in Go.
Typescript types more like hints to the rest of the code.
At any point you can override them or simply use <code>any</code>.
They&rsquo;re there to help you write code that works, but they don&rsquo;t change the program that will be actually executed.</p><p>This is something that took me some time to wrap my head around &ndash; <strong>It is a better mental model to think of Typescript as a very advanced linter for Javascript with type syntax than to think of it as a proper typed language that gets compiled into Javascript</strong> &ndash; Most Typescript typing code you write <em>does not</em> get compiled into Javascript, it is just used for compilation checks and then removed. If you want to have real type checks in runtime using Typescript, you have to use <a href=https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards>type guards</a></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://vaghetti.dev/posts/children/><span class=title>« Prev Page</span><br><span>Is it ethical to have children if you believe their lives will suck?</span>
</a><a class=next href=https://vaghetti.dev/posts/science/><span class=title>Next Page »</span><br><span>"You Don't Need to Trust Science Because You Can Test It." - but Can You?</span></a></nav></footer><footer class=footer><div style=float:left><applause-button style="width: 64px; height: 64px; color: var(--content)" multiclap=true url=https://vaghetti.dev/posts/typescript-types/></div><div><h2>Want to get notified about future posts?</h2><h2>Subscribe through <a href=/index.xml>RSS</a> or just <a href=https://twitter.com/ovaghetti>Follow me
on
twitter</a></h2><h2>Wanna share your thoughts? <a href=/>Get in touch</a></h2></div></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>